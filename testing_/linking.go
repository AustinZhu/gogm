// Code generated by GoGM v1.0.1. DO NOT EDIT
package testing_

import (
	"errors"
)

// LinkToExampleObjectOnFieldChildren links ExampleObject to ExampleObject on the fields ExampleObject.Children and ExampleObject.Parents
func (l *ExampleObject) LinkToExampleObjectOnFieldChildren(targets ...*ExampleObject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children == nil {
			l.Children = make([]*ExampleObject, 1, 1)
			l.Children[0] = target
		} else {
			l.Children = append(l.Children, target)
		}

		target.Parents = l
	}

	return nil
}

//UnlinkFromExampleObjectOnFieldChildren unlinks ExampleObject from ExampleObject on the fields ExampleObject.Children and ExampleObject.Parents
func (l *ExampleObject) UnlinkFromExampleObjectOnFieldChildren(targets ...*ExampleObject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children != nil {
			for i, unlinkTarget := range l.Children {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Children
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Parents = nil
	}

	return nil
}

//LinkToExampleObjectOnFieldParents links ExampleObject to ExampleObject on the fields ExampleObject.Parents and ExampleObject.Children
func (l *ExampleObject) LinkToExampleObjectOnFieldParents(target *ExampleObject) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Parents = target

	if target.Children == nil {
		target.Children = make([]*ExampleObject, 1, 1)
		target.Children[0] = l
	} else {
		target.Children = append(target.Children, l)
	}

	return nil
}

//UnlinkFromExampleObjectOnFieldParents unlinks ExampleObject from ExampleObject on the fields ExampleObject.Parents and ExampleObject.Children
func (l *ExampleObject) UnlinkFromExampleObjectOnFieldParents(target *ExampleObject) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Parents = nil

	if target.Children != nil {
		for i, unlinkTarget := range target.Children {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Children
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToExampleObject2OnFieldSpecial links ExampleObject to ExampleObject2 on the fields ExampleObject.Special and ExampleObject2.Special.
// note this uses the special edge SpecialEdge
func (l *ExampleObject) LinkToExampleObject2OnFieldSpecial(target *ExampleObject2, edge *SpecialEdge) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(target)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(l)
	if err != nil {
		return err
	}

	l.Special = edge

	if target.Special == nil {
		target.Special = make([]*SpecialEdge, 1, 1)
		target.Special[0] = edge
	} else {
		target.Special = append(target.Special, edge)
	}

	return nil
}

// UnlinkFromExampleObject2OnFieldSpecial unlinks ExampleObject from ExampleObject2 on the fields ExampleObject.Special and ExampleObject2.Special.
// also note this uses the special edge SpecialEdge
func (l *ExampleObject) UnlinkFromExampleObject2OnFieldSpecial(target *ExampleObject2) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Special = nil

	if target.Special != nil {
		for i, unlinkTarget := range target.Special {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*ExampleObject)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*ExampleObject]")
			}
			if checkObj.UUID == l.UUID {
				a := &target.Special
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToExampleObject2OnFieldChildren2 links ExampleObject2 to ExampleObject2 on the fields ExampleObject2.Children2 and ExampleObject2.Parents2
func (l *ExampleObject2) LinkToExampleObject2OnFieldChildren2(targets ...*ExampleObject2) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children2 == nil {
			l.Children2 = make([]*ExampleObject2, 1, 1)
			l.Children2[0] = target
		} else {
			l.Children2 = append(l.Children2, target)
		}

		target.Parents2 = l
	}

	return nil
}

//UnlinkFromExampleObject2OnFieldChildren2 unlinks ExampleObject2 from ExampleObject2 on the fields ExampleObject2.Children2 and ExampleObject2.Parents2
func (l *ExampleObject2) UnlinkFromExampleObject2OnFieldChildren2(targets ...*ExampleObject2) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children2 != nil {
			for i, unlinkTarget := range l.Children2 {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Children2
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Parents2 = nil
	}

	return nil
}

//LinkToExampleObject2OnFieldParents2 links ExampleObject2 to ExampleObject2 on the fields ExampleObject2.Parents2 and ExampleObject2.Children2
func (l *ExampleObject2) LinkToExampleObject2OnFieldParents2(target *ExampleObject2) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Parents2 = target

	if target.Children2 == nil {
		target.Children2 = make([]*ExampleObject2, 1, 1)
		target.Children2[0] = l
	} else {
		target.Children2 = append(target.Children2, l)
	}

	return nil
}

//UnlinkFromExampleObject2OnFieldParents2 unlinks ExampleObject2 from ExampleObject2 on the fields ExampleObject2.Parents2 and ExampleObject2.Children2
func (l *ExampleObject2) UnlinkFromExampleObject2OnFieldParents2(target *ExampleObject2) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Parents2 = nil

	if target.Children2 != nil {
		for i, unlinkTarget := range target.Children2 {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Children2
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToExampleObjectOnFieldSpecial links ExampleObject2 to ExampleObject on the fields ExampleObject2.Special and ExampleObject.Special.
// note this uses the special edge SpecialEdge
func (l *ExampleObject2) LinkToExampleObjectOnFieldSpecial(target *ExampleObject, edge *SpecialEdge) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(l)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(target)
	if err != nil {
		return err
	}

	if l.Special == nil {
		l.Special = make([]*SpecialEdge, 1, 1)
		l.Special[0] = edge
	} else {
		l.Special = append(l.Special, edge)
	}

	target.Special = edge

	return nil
}

// UnlinkFromExampleObjectOnFieldSpecial unlinks ExampleObject2 from ExampleObject on the fields ExampleObject2.Special and ExampleObject.Special.
// also note this uses the special edge SpecialEdge
func (l *ExampleObject2) UnlinkFromExampleObjectOnFieldSpecial(target *ExampleObject) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if l.Special != nil {
		for i, unlinkTarget := range l.Special {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*ExampleObject)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*ExampleObject]")
			}
			if checkObj.UUID == target.UUID {
				a := &l.Special
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	target.Special = nil

	return nil
}

// LinkToTreeNodeOnFieldTrees links RootTreeNode to TreeNode on the fields RootTreeNode.Trees and TreeNode.Roots
func (l *RootTreeNode) LinkToTreeNodeOnFieldTrees(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Trees == nil {
			l.Trees = make([]*TreeNode, 1, 1)
			l.Trees[0] = target
		} else {
			l.Trees = append(l.Trees, target)
		}

		if target.Roots == nil {
			target.Roots = make([]*RootTreeNode, 1, 1)
			target.Roots[0] = l
		} else {
			target.Roots = append(target.Roots, l)
		}
	}

	return nil
}

//UnlinkFromTreeNodeOnFieldTrees unlinks RootTreeNode from TreeNode on the fields RootTreeNode.Trees and TreeNode.Roots
func (l *RootTreeNode) UnlinkFromTreeNodeOnFieldTrees(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Trees != nil {
			for i, unlinkTarget := range l.Trees {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Trees
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Roots != nil {
			for i, unlinkTarget := range target.Roots {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Roots
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToSideTreeNodeOnFieldSides links RootTreeNode to SideTreeNode on the fields RootTreeNode.Sides and SideTreeNode.Roots
func (l *RootTreeNode) LinkToSideTreeNodeOnFieldSides(targets ...*SideTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Sides == nil {
			l.Sides = make([]*SideTreeNode, 1, 1)
			l.Sides[0] = target
		} else {
			l.Sides = append(l.Sides, target)
		}

		if target.Roots == nil {
			target.Roots = make([]*RootTreeNode, 1, 1)
			target.Roots[0] = l
		} else {
			target.Roots = append(target.Roots, l)
		}
	}

	return nil
}

//UnlinkFromSideTreeNodeOnFieldSides unlinks RootTreeNode from SideTreeNode on the fields RootTreeNode.Sides and SideTreeNode.Roots
func (l *RootTreeNode) UnlinkFromSideTreeNodeOnFieldSides(targets ...*SideTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Sides != nil {
			for i, unlinkTarget := range l.Sides {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Sides
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Roots != nil {
			for i, unlinkTarget := range target.Roots {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Roots
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToTreeNodeOnFieldTrees links SideTreeNode to TreeNode on the fields SideTreeNode.Trees and TreeNode.Sides
func (l *SideTreeNode) LinkToTreeNodeOnFieldTrees(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Trees == nil {
			l.Trees = make([]*TreeNode, 1, 1)
			l.Trees[0] = target
		} else {
			l.Trees = append(l.Trees, target)
		}

		if target.Sides == nil {
			target.Sides = make([]*SideTreeNode, 1, 1)
			target.Sides[0] = l
		} else {
			target.Sides = append(target.Sides, l)
		}
	}

	return nil
}

//UnlinkFromTreeNodeOnFieldTrees unlinks SideTreeNode from TreeNode on the fields SideTreeNode.Trees and TreeNode.Sides
func (l *SideTreeNode) UnlinkFromTreeNodeOnFieldTrees(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Trees != nil {
			for i, unlinkTarget := range l.Trees {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Trees
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Sides != nil {
			for i, unlinkTarget := range target.Sides {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Sides
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToRootTreeNodeOnFieldRoots links SideTreeNode to RootTreeNode on the fields SideTreeNode.Roots and RootTreeNode.Sides
func (l *SideTreeNode) LinkToRootTreeNodeOnFieldRoots(targets ...*RootTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Roots == nil {
			l.Roots = make([]*RootTreeNode, 1, 1)
			l.Roots[0] = target
		} else {
			l.Roots = append(l.Roots, target)
		}

		if target.Sides == nil {
			target.Sides = make([]*SideTreeNode, 1, 1)
			target.Sides[0] = l
		} else {
			target.Sides = append(target.Sides, l)
		}
	}

	return nil
}

//UnlinkFromRootTreeNodeOnFieldRoots unlinks SideTreeNode from RootTreeNode on the fields SideTreeNode.Roots and RootTreeNode.Sides
func (l *SideTreeNode) UnlinkFromRootTreeNodeOnFieldRoots(targets ...*RootTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Roots != nil {
			for i, unlinkTarget := range l.Roots {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Roots
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Sides != nil {
			for i, unlinkTarget := range target.Sides {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Sides
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToTreeNodeOnFieldParents links TreeNode to TreeNode on the fields TreeNode.Parents and TreeNode.Children
func (l *TreeNode) LinkToTreeNodeOnFieldParents(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Parents == nil {
			l.Parents = make([]*TreeNode, 1, 1)
			l.Parents[0] = target
		} else {
			l.Parents = append(l.Parents, target)
		}

		if target.Children == nil {
			target.Children = make([]*TreeNode, 1, 1)
			target.Children[0] = l
		} else {
			target.Children = append(target.Children, l)
		}
	}

	return nil
}

//UnlinkFromTreeNodeOnFieldParents unlinks TreeNode from TreeNode on the fields TreeNode.Parents and TreeNode.Children
func (l *TreeNode) UnlinkFromTreeNodeOnFieldParents(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Parents != nil {
			for i, unlinkTarget := range l.Parents {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Parents
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Children != nil {
			for i, unlinkTarget := range target.Children {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Children
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToTreeNodeOnFieldChildren links TreeNode to TreeNode on the fields TreeNode.Children and TreeNode.Parents
func (l *TreeNode) LinkToTreeNodeOnFieldChildren(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children == nil {
			l.Children = make([]*TreeNode, 1, 1)
			l.Children[0] = target
		} else {
			l.Children = append(l.Children, target)
		}

		if target.Parents == nil {
			target.Parents = make([]*TreeNode, 1, 1)
			target.Parents[0] = l
		} else {
			target.Parents = append(target.Parents, l)
		}
	}

	return nil
}

//UnlinkFromTreeNodeOnFieldChildren unlinks TreeNode from TreeNode on the fields TreeNode.Children and TreeNode.Parents
func (l *TreeNode) UnlinkFromTreeNodeOnFieldChildren(targets ...*TreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Children != nil {
			for i, unlinkTarget := range l.Children {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Children
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Parents != nil {
			for i, unlinkTarget := range target.Parents {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Parents
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToRootTreeNodeOnFieldRoots links TreeNode to RootTreeNode on the fields TreeNode.Roots and RootTreeNode.Trees
func (l *TreeNode) LinkToRootTreeNodeOnFieldRoots(targets ...*RootTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Roots == nil {
			l.Roots = make([]*RootTreeNode, 1, 1)
			l.Roots[0] = target
		} else {
			l.Roots = append(l.Roots, target)
		}

		if target.Trees == nil {
			target.Trees = make([]*TreeNode, 1, 1)
			target.Trees[0] = l
		} else {
			target.Trees = append(target.Trees, l)
		}
	}

	return nil
}

//UnlinkFromRootTreeNodeOnFieldRoots unlinks TreeNode from RootTreeNode on the fields TreeNode.Roots and RootTreeNode.Trees
func (l *TreeNode) UnlinkFromRootTreeNodeOnFieldRoots(targets ...*RootTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Roots != nil {
			for i, unlinkTarget := range l.Roots {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Roots
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Trees != nil {
			for i, unlinkTarget := range target.Trees {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Trees
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToSideTreeNodeOnFieldSides links TreeNode to SideTreeNode on the fields TreeNode.Sides and SideTreeNode.Trees
func (l *TreeNode) LinkToSideTreeNodeOnFieldSides(targets ...*SideTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Sides == nil {
			l.Sides = make([]*SideTreeNode, 1, 1)
			l.Sides[0] = target
		} else {
			l.Sides = append(l.Sides, target)
		}

		if target.Trees == nil {
			target.Trees = make([]*TreeNode, 1, 1)
			target.Trees[0] = l
		} else {
			target.Trees = append(target.Trees, l)
		}
	}

	return nil
}

//UnlinkFromSideTreeNodeOnFieldSides unlinks TreeNode from SideTreeNode on the fields TreeNode.Sides and SideTreeNode.Trees
func (l *TreeNode) UnlinkFromSideTreeNodeOnFieldSides(targets ...*SideTreeNode) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Sides != nil {
			for i, unlinkTarget := range l.Sides {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Sides
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Trees != nil {
			for i, unlinkTarget := range target.Trees {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Trees
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}
